<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="A post about why I wrote &quot;hydrate‑text&quot; library"><link rel="icon" href="/blog/favicon.ico"><link rel="icon" href="/blog/assets/favicon/favicon.svg" type="image/svg+xml"><link rel="apple-touch-icon" href="/blog/assets/favicon/apple-touch-icon.png"><link rel="manifest" href="/blog/assets/manifest.webmanifest"><title>Why I wrote &quot;hydrate‑text&quot; library | Vasilii Kovalev's blog</title><style>html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}h1{font-size:2em;margin:.67em 0}dl dl,dl ol,dl ul,ol dl,ul dl{margin:0}ol ol,ol ul,ul ol,ul ul{margin:0}hr{box-sizing:content-box;color:inherit;height:0;overflow:visible}main{display:block}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}abbr[title]{text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}small{font-size:80%}audio,video{display:inline-block}audio:not([controls]){display:none;height:0}img{border-style:none}svg:not(:root){overflow:hidden}table{border-color:inherit;text-indent:0}button,input,select{margin:0}button{overflow:visible;text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}fieldset{padding:.35em .75em .625em}input{overflow:visible}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;white-space:normal}progress{display:inline-block;vertical-align:baseline}select{text-transform:none}textarea{margin:0;overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}::-moz-focus-inner{border-style:none;padding:0}:-moz-focusring{outline:1px dotted ButtonText}:-moz-ui-invalid{box-shadow:none}details{display:block}dialog{background-color:#fff;border:solid;color:#000;display:block;height:-moz-fit-content;height:-webkit-fit-content;height:fit-content;left:0;margin:auto;padding:1em;position:absolute;right:0;width:-moz-fit-content;width:-webkit-fit-content;width:fit-content}dialog:not([open]){display:none}summary{display:list-item}canvas{display:inline-block}template{display:none}[hidden]{display:none}</style><style>:root{--text-color:black;--background-color:white;--border-radius:4px}@media (prefers-color-scheme:dark){:root{--text-color:#d7dae0;--background-color:#202124}}body{background-color:var(--background-color);color:var(--text-color);font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-size:100%;line-height:150%;margin:0 auto;max-width:40em;padding:0 1em}h1{line-height:125%}h2{line-height:150%}a{color:var(--textLink)}a:is(:hover,:focus){background-color:var(--text-color);border-radius:2px;color:var(--background-color);outline:0;text-decoration:none}ul{padding-inline-start:20px}.header,.social-links{align-items:center;display:flex;flex-wrap:wrap}.header{justify-content:space-between}.social-links{list-style:none;padding:0}.social-links__link+.social-links__link{margin-left:24px}</style><style>:is(h2,h3,h4,h5,h6):focus-visible{outline:0}a[href*="#"]:not(.header-anchor){font-style:italic}code:not([class*=language]){border:1px solid var(--text-color);border-radius:2px;font-size:85%;margin:0 1px;padding:1px 3px}pre{border:2px solid var(--text-color);border-radius:var(--border-radius);color:var(--text-color);overflow-x:auto;padding:12px}a:is(:hover,:focus) code:not([class*=language]){border-color:transparent}.header-anchor::before{content:"#"}.code-header{background-color:var(--text-color);border:2px solid var(--text-color);border-bottom:none;border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);color:var(--background-color);display:flex;flex-direction:column;flex-wrap:wrap;font-family:monospace,monospace;justify-content:space-between;padding:4px}.code-header__file{font-size:75%;word-break:break-word}.code-header+pre{border-top-left-radius:0;border-top-right-radius:0;margin-top:0}.footer{padding-bottom:2em}</style></head><body><header class="header"><a href="/blog/" class="header__logo">Vasilii Kovalev's blog (WIP)</a><ul class="social-links"><li class="social-links__link"><a href="https://twitter.com/vasilii_kovalev">Twitter</a></li><li class="social-links__link"><a href="https://github.com/vasilii-kovalev">GitHub</a></li></ul></header><main><article><h1>Why I wrote &quot;hydrate‑text&quot; library</h1><h2 id="internationalization-with-i18next" tabindex="-1"><a class="header-anchor" href="#internationalization-with-i18next">Internationalization with i18next</a></h2><p>On one of my projects at work, we used <a href="https://www.i18next.com/">i18next</a> library (along with <a href="https://react.i18next.com/">react-i18next</a>) to manage internationalization in a React application. To implement it, it is usually necessary to do this:</p><ul><li><p>Define an <code>i18next</code> instance</p><div class="code-header"><span class="code-header__language">JavaScript </span><span class="code-header__file">src/i18n/index.js</span></div><pre><code class="language-javascript">import i18n from &quot;i18next&quot;;
import { initReactI18next } from &quot;react-i18next&quot;;
import LanguageDetector from &quot;i18next-browser-languagedetector&quot;;

import {
  en,
  ru,
  // ... other locales
} from &quot;./locales&quot;;

const resources = {
  en,
  ru,
  // ... other locales
};

i18n
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    detection: {
      lookupQuerystring: &quot;lng&quot;,
      order: [&quot;querystring&quot;],
    },

    fallbackLng: &quot;en&quot;,
    interpolation: {
      // Not needed for React
      escapeValue: false,
    },
    resources,
  });

export default i18n;
</code></pre></li><li><p>Define the resources</p><div class="code-header"><span class="code-header__language">JavaScript </span><span class="code-header__file">src/i18n/locales/index.js</span></div><pre><code class="language-javascript">export { en } from &quot;./en&quot;;
export { ru } from &quot;./ru&quot;;
// ... other locales
</code></pre><div class="code-header"><span class="code-header__language">JavaScript </span><span class="code-header__file">src/i18n/locales/en/index.js</span></div><pre><code class="language-javascript">import errors from &quot;./errors.json&quot;;
// ... other namespaces

const en = {
  errors,
  // ... other namespaces
};

export { en };
</code></pre><div class="code-header"><span class="code-header__language">JSON </span><span class="code-header__file">src/i18n/locales/en/errors.json</span></div><pre><code class="language-json">{
  &quot;validation&quot;: {
    &quot;field&quot;: {
      &quot;is&quot;: {
        &quot;empty&quot;: &quot;This field is required&quot;,
        &quot;incorrect&quot;: {
          &quot;password&quot;: &quot;Password is incorrect&quot;
        },
        &quot;invalid&quot;: {
          &quot;common&quot;: &quot;Please enter a valid value&quot;,
          &quot;email&quot;: &quot;Please enter a valid email address&quot;
        }
      },
      &quot;length&quot;: {
        &quot;lessThan&quot;: &quot;This field should contain at least  characters&quot;,
        &quot;moreThan&quot;: &quot;This field should contain no more than  characters&quot;
      }
    },
    &quot;fields&quot;: {
      &quot;are&quot;: {
        &quot;not&quot;: {
          &quot;equal&quot;: {
            &quot;password&quot;: &quot;Passwords don't match&quot;
          }
        }
      }
    }
  }
}
</code></pre><div class="code-header"><span class="code-header__language">JavaScript </span><span class="code-header__file">src/i18n/locales/ru/index.js</span></div><pre><code class="language-javascript">import errors from &quot;./errors.json&quot;;
// ... other namespaces

const ru = {
  errors,
  // ... other namespaces
};

export { ru };
</code></pre><div class="code-header"><span class="code-header__language">JSON </span><span class="code-header__file">src/i18n/locales/ru/errors.json</span></div><pre><code class="language-json">{
  &quot;validation&quot;: {
    &quot;field&quot;: {
      &quot;is&quot;: {
        &quot;empty&quot;: &quot;Это поле является обязательным для заполнения&quot;,
        &quot;incorrect&quot;: {
          &quot;password&quot;: &quot;Неверный пароль&quot;
        },
        &quot;invalid&quot;: {
          &quot;common&quot;: &quot;Пожалуйста, введите корректное значение&quot;,
          &quot;email&quot;: &quot;Пожалуйста, введите корректный адрес электронной почты&quot;
        }
      },
      &quot;length&quot;: {
        &quot;lessThan&quot;: &quot;Это поле должно состоять минимум из  символов&quot;,
        &quot;moreThan&quot;: &quot;Это поле должно состоять максимум из  символов&quot;
      }
    },
    &quot;fields&quot;: {
      &quot;are&quot;: {
        &quot;not&quot;: {
          &quot;equal&quot;: {
            &quot;password&quot;: &quot;Пароли не совпадают&quot;
          }
        }
      }
    }
  }
}
</code></pre></li><li><p>Import the <code>i18n</code> instance</p><div class="code-header"><span class="code-header__language">JavaScript </span><span class="code-header__file">src/main.jsx</span></div><pre><code class="language-javascript">import * as React from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;

import &quot;./i18n&quot;;
import { App } from &quot;./app&quot;;

ReactDOM.render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;,
  document.getElementById(&quot;root&quot;),
);
</code></pre></li><li><p>Pass the translation function to a component via special HOC/React Hook</p><div class="code-header"><span class="code-header__language">JavaScript </span><span class="code-header__file">src/components/app.jsx</span></div><pre><code class="language-javascript">import * as React from &quot;react&quot;;
// The HOC
import { withTranslation } from &quot;react-i18next&quot;;

const App = ({ t }) =&gt; {
  /*
    &quot;This field should contain at least 10 characters&quot; for English.
    &quot;Это поле должно состоять минимум из 10 символов&quot; for Russian.
  */
  const translatedText = t(&quot;errors:validation.field.length.lessThan&quot;, {
    minLength: 10,
  });

  return &lt;h1&gt;{translatedText}&lt;/h1&gt;;
};

const AppWithTranslation = withTranslation()(App);

export { AppWithTranslation as App };
</code></pre><p>Or</p><div class="code-header"><span class="code-header__language">JavaScript </span><span class="code-header__file">src/components/app.jsx</span></div><pre><code class="language-javascript">import * as React from &quot;react&quot;;
// The React Hook
import { useTranslation } from &quot;react-i18next&quot;;

const App = () =&gt; {
  const { t } = useTranslation();

  /*
    &quot;This field should contain at least 10 characters&quot; for English.
    &quot;Это поле должно состоять минимум из 10 символов&quot; for Russian.
  */
  const translatedText = t(&quot;errors:validation.field.length.lessThan&quot;, {
    minLength: 10,
  });

  return &lt;h1&gt;{translatedText}&lt;/h1&gt;;
};

export { App };
</code></pre></li></ul><p>Either way, the component gets the <code>t</code> function. The function accepts a path to a localization string (see JSON files above), and an object with variables, which are put in the slots (defined in double curly braces) in the string.</p><p>The full source code is available here: <a href="https://github.com/vasilii-kovalev/react-internationalization-i18next">link</a>.</p><h2 id="the-problems" tabindex="-1"><a class="header-anchor" href="#the-problems">The problems</a></h2><p>The whole approach looks reasonable, but there are some problems with it:</p><ul><li>Path to a localization string is a plain string, so it is easy to make typos. It is also easy to forget to define a namespace or make typos in it as well. It is necessary to thoroughly check each part of the path to make sure it leads to a correct localization string.</li><li>The packages are heavy: the described approach in total takes ~55.1 KiB, ~51 KiB of which is the packages' code. Check out &quot;Measuring application sizes&quot; section below for more information.</li><li>It is hard to keep the files' structure synchronized between locales. A sub-tree can be missed in a resource, and nothing will tell about that until <a href="https://www.i18next.com/overview/configuration-options#missing-keys">missing keys</a> feature will handle it (if enabled).</li></ul><p>We wrote that application using JavaScript back then. After several years I learned TypeScript and realized, how to solve all these problems.</p><h2 id="the-solution" tabindex="-1"><a class="header-anchor" href="#the-solution">The solution</a></h2><p>I like the API of the <code>t</code> function (path to a localization string and a bunch of variables to &quot;hydrate&quot; it), so I decided to copy it in a standalone package, that is known as <a href="https://github.com/vasilii-kovalev/hydrate-text">&quot;hydrate‑text&quot;</a>. Now let's implement our own i18n solution with it.</p><ul><li><p>Define supported languages and a default one</p><div class="code-header"><span class="code-header__language">TypeScript </span><span class="code-header__file">src/i18n/constants.ts</span></div><pre><code class="language-typescript">const SUPPORTED_LANGUAGES_MAP = {
  en: &quot;en&quot;,
  ru: &quot;ru&quot;,
  // ... other languages
} as const;

const DEFAULT_SELECTED_LANGUAGE = SUPPORTED_LANGUAGES_MAP.en;

export { DEFAULT_SELECTED_LANGUAGE, SUPPORTED_LANGUAGES_MAP };
</code></pre></li><li><p>Define a &quot;dictionary&quot; (a structure, that will be used to type checking our localization resources)</p><div class="code-header"><span class="code-header__language">TypeScript </span><span class="code-header__file">src/i18n/dictionary/index.ts</span></div><pre><code class="language-typescript">import { errors } from &quot;./errors&quot;;
// ... other namespaces

const dictionary = {
  errors,
  // ... other namespaces
} as const;

export { dictionary };
</code></pre><div class="code-header"><span class="code-header__language">TypeScript </span><span class="code-header__file">src/i18n/dictionary/errors.ts</span></div><pre><code class="language-typescript">const errors = {
  validation: {
    field: {
      is: {
        empty: &quot;errors.validation.field.is.empty&quot;,
        incorrect: {
          password: &quot;errors.validation.field.is.incorrect.password&quot;,
        },
        invalid: {
          common: &quot;errors.validation.field.is.invalid.common&quot;,
          email: &quot;errors.validation.field.is.invalid.email&quot;,
        },
      },
      length: {
        lessThan: &quot;errors.validation.field.length.lessThan&quot;,
        moreThan: &quot;errors.validation.field.length.moreThan&quot;,
      },
    },
    fields: {
      are: {
        not: {
          equal: {
            password: &quot;errors.validation.fields.are.not.equal.password&quot;,
          },
        },
      },
    },
  },
} as const;

export { errors };
</code></pre><p><code>as const</code> expressions require all the resources to strictly follow the structure.</p><p><strong>Note:</strong> it can be hard to fill in these strings manually, so I just assign empty strings to them and pass the whole structure to this function below.</p><div class="code-header"><span class="code-header__language">JavaScript</span></div><pre><code class="language-javascript">const fillTreePaths = (treeWithEmptyPaths, namespace = &quot;&quot;) =&gt; {
  const traverse = (currentTree, parentPath) =&gt;
    Object.entries(currentTree).reduce((updatedCurrentTree, [key, value]) =&gt; {
      const currentPath = `${parentPath}.${key}`;

      if (typeof value === &quot;string&quot;) {
        return {
          ...updatedCurrentTree,
          [key]: currentPath,
        };
      }

      return {
        ...updatedCurrentTree,
        [key]: traverse(value, currentPath),
      };
    }, {});

  const newTree = traverse(treeWithEmptyPaths, namespace);

  const stringifiedTree = JSON.stringify(newTree, null, 2);
  const refinedTree = stringifiedTree
    // Removes double quote before keys.
    .replace(/(\s{2,})&quot;/g, &quot;$1&quot;)
    // Removes double quote right after keys and before colons.
    .replace(/&quot;(: )/g, &quot;$1&quot;);

  return refinedTree;
};

/*
Returns
{
  validation: {
    field: {
      is: {
        empty: &quot;errors.validation.field.is.empty&quot;,
        incorrect: {
          password: &quot;errors.validation.field.is.incorrect.password&quot;,
        },
        invalid: {
          common: &quot;errors.validation.field.is.invalid.common&quot;,
          email: &quot;errors.validation.field.is.invalid.email&quot;,
        },
      },
      length: {
        lessThan: &quot;errors.validation.field.length.lessThan&quot;,
        moreThan: &quot;errors.validation.field.length.moreThan&quot;,
      },
    },
    fields: {
      are: {
        not: {
          equal: {
            password: &quot;errors.validation.fields.are.not.equal.password&quot;,
          },
        },
      },
    },
  },
}
*/
fillTreePaths(
  {
    validation: {
      field: {
        is: {
          empty: &quot;&quot;,
          incorrect: {
            password: &quot;&quot;,
          },
          invalid: {
            common: &quot;&quot;,
            email: &quot;&quot;,
          },
        },
        length: {
          lessThan: &quot;&quot;,
          moreThan: &quot;&quot;,
        },
      },
      fields: {
        are: {
          not: {
            equal: {
              password: &quot;&quot;,
            },
          },
        },
      },
    },
  },
  &quot;errors&quot;,
);
</code></pre></li><li><p>Define types for the resources</p><div class="code-header"><span class="code-header__language">TypeScript </span><span class="code-header__file">src/i18n/types.ts</span></div><pre><code class="language-typescript">import { SUPPORTED_LANGUAGES_MAP } from &quot;./constants&quot;;
import { dictionary } from &quot;./dictionary&quot;;

type Keys&lt;Type&gt; = keyof Type;

type Values&lt;Type&gt; = Type[Keys&lt;Type&gt;];

/*
  Turns particular string values into abstract 'string' type.
  It allows to type translations with I18nPaths subtypes, because otherwise
  TypeScript will be complaining that values of translations are not the same
  as paths ones.
*/
type GetDictionary&lt;Type&gt; = Type extends string
  ? string
  : { [Path in Keys&lt;Type&gt;]: GetDictionary&lt;Type[Path]&gt; };

type Dictionary = GetDictionary&lt;typeof dictionary&gt;;

type SupportedLanguage = Values&lt;typeof SUPPORTED_LANGUAGES_MAP&gt;;

type Dictionaries = {
  [Language in SupportedLanguage]: Dictionary;
};

export type { Dictionaries, Dictionary, SupportedLanguage };
</code></pre></li><li><p>Define the resources (I called them <code>dictionaries</code> for consistency) for the supported languages</p><div class="code-header"><span class="code-header__language">TypeScript </span><span class="code-header__file">src/i18n/dictionaries/index.ts</span></div><pre><code class="language-typescript">import { Dictionaries } from &quot;../types&quot;;

import { englishDictionary as en } from &quot;./en&quot;;
import { russianDictionary as ru } from &quot;./ru&quot;;
// ... other dictionaries

const dictionaries: Dictionaries = {
  en,
  ru,
  // ... other dictionaries
};

export { dictionaries };
</code></pre><div class="code-header"><span class="code-header__language">TypeScript </span><span class="code-header__file">src/i18n/dictionaries/en/index.ts</span></div><pre><code class="language-typescript">import { Dictionary } from &quot;i18n/types&quot;;

import { errors } from &quot;./errors&quot;;
// ... other namespaces

const englishDictionary: Dictionary = {
  errors,
  // ... other namespaces
};

export { englishDictionary };
</code></pre><div class="code-header"><span class="code-header__language">TypeScript </span><span class="code-header__file">src/i18n/dictionaries/en/errors.ts</span></div><pre><code class="language-typescript">import { Dictionary } from &quot;i18n/types&quot;;

const errors: Dictionary[&quot;errors&quot;] = {
  validation: {
    field: {
      is: {
        empty: &quot;This field is required&quot;,
        incorrect: {
          password: &quot;Password is incorrect&quot;,
        },
        invalid: {
          common: &quot;Please enter a valid value&quot;,
          email: &quot;Please enter a valid email address&quot;,
        },
      },
      length: {
        lessThan: &quot;This field should contain at least {minLength} characters&quot;,
        moreThan: `This field should contain no more than {maxLength}
        characters`,
      },
    },
    fields: {
      are: {
        not: {
          equal: {
            password: &quot;Passwords don't match&quot;,
          },
        },
      },
    },
  },
};

export { errors };
</code></pre><div class="code-header"><span class="code-header__language">TypeScript </span><span class="code-header__file">src/i18n/dictionaries/ru/index.ts</span></div><pre><code class="language-typescript">import { Dictionary } from &quot;i18n/types&quot;;

import { errors } from &quot;./errors&quot;;
// ... other namespaces

const russianDictionary: Dictionary = {
  errors,
  // ... other namespaces
};

export { russianDictionary };
</code></pre><div class="code-header"><span class="code-header__language">TypeScript </span><span class="code-header__file">src/i18n/dictionaries/ru/errors.ts</span></div><pre><code class="language-typescript">import { Dictionary } from &quot;i18n/types&quot;;

const errors: Dictionary[&quot;errors&quot;] = {
  validation: {
    field: {
      is: {
        empty: &quot;Это поле является обязательным для заполнения&quot;,
        incorrect: {
          password: &quot;Неверный пароль&quot;,
        },
        invalid: {
          common: &quot;Пожалуйста, введите корректное значение&quot;,
          email: &quot;Пожалуйста, введите корректный адрес электронной почты&quot;,
        },
      },
      length: {
        lessThan: &quot;Это поле должно состоять минимум из {minLength} символов&quot;,
        moreThan: &quot;Это поле должно состоять максимум из {maxLength} символов&quot;,
      },
    },
    fields: {
      are: {
        not: {
          equal: {
            password: &quot;Пароли не совпадают&quot;,
          },
        },
      },
    },
  },
};

export { errors };
</code></pre></li><li><p>Create i18n context, context provider and React Hook</p><div class="code-header"><span class="code-header__language">TypeScript </span><span class="code-header__file">src/i18n/context.tsx</span></div><pre><code class="language-typescript">import { HydrateText } from &quot;hydrate-text&quot;;
import * as React from &quot;react&quot;;

import { DEFAULT_SELECTED_LANGUAGE } from &quot;./constants&quot;;
import { SupportedLanguage } from &quot;./types&quot;;
import { isSupportedLanguage, textResolver } from &quot;./utils&quot;;
import { dictionaries } from &quot;./dictionaries&quot;;

interface I18nContextInterface {
  selectedLanguage: SupportedLanguage;
  setLanguage: (newSelectedLanguage: SupportedLanguage) =&gt; void;
  translate: HydrateText;
}

const I18nContext = React.createContext&lt;I18nContextInterface&gt;({
  selectedLanguage: DEFAULT_SELECTED_LANGUAGE,
  setLanguage: () =&gt; {
    // no-op
  },
  translate: () =&gt; &quot;&quot;,
});

const I18nProvider: React.FC = ({ children }) =&gt; {
  const [selectedLanguage, setLanguage] = React.useState&lt;SupportedLanguage&gt;(
    DEFAULT_SELECTED_LANGUAGE,
  );

  React.useEffect(() =&gt; {
    const searchParams = new URLSearchParams(window.location.search);

    const language = searchParams.get(&quot;lng&quot;);

    if (isSupportedLanguage(language)) {
      setLanguage(language);
    }
  }, []);

  const translate = React.useMemo(
    () =&gt; textResolver(dictionaries[selectedLanguage]),
    [selectedLanguage],
  );

  const value = {
    selectedLanguage,
    setLanguage,
    translate,
  };

  return (
    &lt;I18nContext.Provider value={value}&gt;{children}&lt;/I18nContext.Provider&gt;
  );
};

const useI18n = (): I18nContextInterface =&gt; {
  return React.useContext(I18nContext);
};

export { I18nContext, I18nProvider, useI18n };
</code></pre><div class="code-header"><span class="code-header__language">TypeScript </span><span class="code-header__file">src/i18n/utils.ts</span></div><pre><code class="language-typescript">import { HydrateText, hydrateText } from &quot;hydrate-text&quot;;
import get from &quot;lodash/get&quot;;

import { SUPPORTED_LANGUAGES_MAP } from &quot;./constants&quot;;
import { Dictionary, SupportedLanguage } from &quot;./types&quot;;

const textResolver =
  (dictionary: Dictionary): HydrateText =&gt;
  (pathOrText, variables, interpolationOptions) =&gt; {
    return hydrateText(
      get(dictionary, pathOrText, pathOrText),
      variables,
      interpolationOptions,
    );
  };

const isSupportedLanguage = (
  language: string | null,
): language is SupportedLanguage =&gt; {
  return Object.values(SUPPORTED_LANGUAGES_MAP).includes(
    language as SupportedLanguage,
  );
};

export { textResolver, isSupportedLanguage };
</code></pre></li><li><p>Wrap the application in the context provider</p><div class="code-header"><span class="code-header__language">TypeScript </span><span class="code-header__file">src/main.tsx</span></div><pre><code class="language-typescript">import * as React from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;

import { I18nProvider } from &quot;i18n&quot;;

import { App } from &quot;./app&quot;;

ReactDOM.render(
  &lt;React.StrictMode&gt;
    &lt;I18nProvider&gt;
      &lt;App /&gt;
    &lt;/I18nProvider&gt;
  &lt;/React.StrictMode&gt;,
  document.getElementById(&quot;root&quot;),
);
</code></pre></li><li><p>Use the React Hook to get the translation function</p><div class="code-header"><span class="code-header__language">TypeScript </span><span class="code-header__file">src/app.tsx</span></div><pre><code class="language-typescript">import * as React from &quot;react&quot;;

import { dictionary, useI18n } from &quot;i18n&quot;;

const { field } = dictionary.errors.validation;

const App: React.VFC = () =&gt; {
  const { translate } = useI18n();

  /*
    &quot;This field should contain at least 10 characters&quot; for English.
    &quot;Это поле должно состоять минимум из 10 символов&quot; for Russian.
  */
  const translatedText = translate(field.length.lessThan, {
    minLength: 10,
  });

  return &lt;h1&gt;{translatedText}&lt;/h1&gt;;
};

export { App };
</code></pre></li></ul><p>The full source code is available here: <a href="https://github.com/vasilii-kovalev/react-internationalization-hydrate-text">link</a>.</p><p>Now all the problems are solved:</p><ul><li>The path to a localization string is not a plain string now, but a structure, that won't let you make a typo.</li><li>The described approach adds ~8.3 KiB to the bundle (the heaviest part is <a href="https://lodash.com/docs/4.17.15#get"><code>get</code> function from Lodash</a>, that takes ~6.8 KiB). It is a way smaller than the previous one, and it is fully customizable on any level. Check out &quot;Measuring application sizes&quot; section below for more information.</li><li><code>Dictionary</code> type guarantees, that all resources (dictionaries) have the same structure.</li></ul><h2 id="keeping-text-organized" tabindex="-1"><a class="header-anchor" href="#keeping-text-organized">Keeping text organized</a></h2><p>Even if localization is not necessary, I believe it is still a good idea to keep text organized. In this case, the following approach can be used:</p><ul><li><p>Define a text constant</p><div class="code-header"><span class="code-header__language">TypeScript </span><span class="code-header__file">src/constants/text/errors.ts</span></div><pre><code class="language-typescript">const ERRORS_TEXT = {
  validation: {
    field: {
      is: {
        empty: &quot;This field is required&quot;,
        incorrect: {
          password: &quot;Password is incorrect&quot;,
        },
        invalid: {
          common: &quot;Please enter a valid value&quot;,
          email: &quot;Please enter a valid email address&quot;,
        },
      },
      length: {
        lessThan: &quot;This field should contain at least {minLength} characters&quot;,
        moreThan: `This field should contain no more than {maxLength}
        characters`,
      },
    },
    fields: {
      are: {
        not: {
          equal: {
            password: &quot;Passwords don't match&quot;,
          },
        },
      },
    },
  },
};
</code></pre></li><li><p>Use <code>hydrate‑text</code> to provide the text with variables</p><div class="code-header"><span class="code-header__language">TypeScript </span><span class="code-header__file">src/app.tsx</span></div><pre><code class="language-typescript">import { hydrateText } from &quot;hydrate-text&quot;;
import * as React from &quot;react&quot;;

import { ERRORS_TEXT } from &quot;constants/text/errors&quot;;

const { field } = ERRORS_TEXT.validation;

const App: React.VFC = () =&gt; {
  /*
    &quot;This field should contain at least 10 characters&quot;.
  */
  const text = hydrateText(field.length.lessThan, {
    minLength: 10,
  });

  return &lt;h1&gt;{text}&lt;/h1&gt;;
};

export { App };
</code></pre></li></ul><h2 id="replacing-route-variables" tabindex="-1"><a class="header-anchor" href="#replacing-route-variables">Replacing route variables</a></h2><p>In some cases, it is necessary to provide <a href="https://reactrouter.com/">React Router</a> routes with variables, like this:</p><div class="code-header"><span class="code-header__language">TypeScript</span></div><pre><code class="language-typescript">// Given
&quot;/posts/:id&quot;;

// Needed (for example, `id` is 10)
&quot;/posts/10&quot;;
</code></pre><p>To achieve this, an ability to replace default variable markers was added. In the source code it is called &quot;interpolation options&quot; (this name was taken from <code>i18next</code> <a href="https://www.i18next.com/translation-function/interpolation#additional-options">&quot;Interpolation&quot; page</a>):</p><div class="code-header"><span class="code-header__language">TypeScript</span></div><pre><code class="language-typescript">// &quot;/posts/10&quot;
hydrateText(
  &quot;/posts/:id&quot;,
  { id: 10 },
  {
    prefix: &quot;:&quot;,
    suffix: &quot;&quot;,
  },
);
</code></pre><p>If it is necessary to do this in several places, it is better to use another function from <code>hydrate‑text</code> - <code>configureHydrateText</code>, which will return <code>hydrateText</code> function bound to the chosen variable markers:</p><div class="code-header"><span class="code-header__language">TypeScript</span></div><pre><code class="language-typescript">const hydrateRoute = configureHydrateText({
  prefix: &quot;:&quot;,
  suffix: &quot;&quot;,
});

// &quot;/posts/10&quot;
hydrateRoute(&quot;/posts/:id&quot;, { id: 10 });
</code></pre><p>The markers still can be changed via the third argument, but I can hardly imagine, when it can be useful 🙂</p><p>Later on I found a built-in function <a href="https://reactrouter.com/web/api/generatePath">generatePath</a>, but the examples above are still valid as an illustration of the variable markers changing flexibility.</p><h2 id="measuring-application-sizes" tabindex="-1"><a class="header-anchor" href="#measuring-application-sizes">Measuring application sizes</a></h2><h3 id="i18next" tabindex="-1"><a class="header-anchor" href="#i18next">i18next</a></h3><p>In each case, check console results and sum up <code>dist/assets/index.&lt;hash&gt;.js</code> and <code>dist/assets/vendor.&lt;hash&gt;.js</code> sizes.</p><ol><li>Build the application as is: <strong>1.34 KiB + 181.54 KiB</strong>.</li><li>Replace <code>&lt;App /&gt;</code> by <code>null</code>, comment out <code>i18n</code> and <code>App</code> imports and build the application: <strong>0.14 KiB + 127.59 KiB</strong>.</li></ol><p>The sizes were double-checked with <a href="https://marketplace.visualstudio.com/items?itemName=mkxml.vscode-filesize">filesize</a> VS Code extension.</p><p>We miss <code>withTranslation</code>/<code>useTranslation</code> import costs, but I don't think it drastically changes the picture.</p><h3 id="hydrate%E2%80%91text" tabindex="-1"><a class="header-anchor" href="#hydrate%E2%80%91text">hydrate‑text</a></h3><p>In each case, check console results and sum up <code>dist/assets/index.&lt;hash&gt;.js</code> and <code>dist/assets/vendor.&lt;hash&gt;.js</code> sizes.</p><ol><li>Build the application as is: <strong>2.16 KiB + 133.91 KiB</strong>.</li><li>Replace <code>get(dictionary, pathOrText, pathOrText)</code> by <code>pathOrText</code>, comment out <code>get</code> import and build the application: <strong>1.25 KiB + 128.01 KiB</strong>.</li><li>Replace <code>&lt;I18nProvider&gt;&lt;App /&gt;&lt;/I18nProvider&gt;</code> by <code>null</code>, comment out <code>I18nProvider</code> and <code>App</code> imports and build the application: <strong>0.14 KiB + 127.59 KiB</strong>.</li></ol><p>The sizes were double-checked with <a href="https://marketplace.visualstudio.com/items?itemName=mkxml.vscode-filesize">filesize</a> VS Code extension.</p></article></main><footer class="footer"><a href="https://github.com/vasilii-kovalev/blog/blob/main/src/posts/why-i-wrote-hydrate-text-library/index.md">Edit this page on GitHub</a></footer></body></html>