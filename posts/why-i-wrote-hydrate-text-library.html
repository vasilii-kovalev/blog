<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="icon" href="../favicon.ico" />
    <link
      rel="icon"
      href="../assets/favicon/favicon.svg"
      type="image/svg+xml"
    />
    <link
      rel="apple-touch-icon"
      href="../assets/favicon/apple-touch-icon.png"
    />
    <link rel="manifest" href="../assets/manifest.webmanifest" />

    <link rel="stylesheet" href="../styles/normalize.css" />
    <link rel="stylesheet" href="../styles/common.css" />

    <title>Why I wrote "hydrate-text" library</title>
  </head>
  <body>
    <header>
      <div class="header__content">
        <div class="logo">
          <a href="../" class="logo__link">
            <img
              src="../assets/favicon/favicon.svg"
              width="48"
              height="48"
              class="logo__image"
              alt="Logo"
            />
            Vasilii Kovalev's blog (WIP)
          </a>
        </div>

        <ul class="social-links">
          <li class="social-link">
            <a href="https://twitter.com/vasilii_kovalev">Twitter</a>
          </li>
          <li class="social-link">
            <a href="https://github.com/vasilii-kovalev">GitHub</a>
          </li>
        </ul>
      </div>
    </header>

    <main>
      <h1>Why I wrote "hydrate-text" library</h1>
      <h2 id="internationalization-with-i18next">
        <a href="#internationalization-with-i18next"
          >Internationalization with i18next</a
        >
      </h2>
      <p>
        On one of my projects at work, we used
        <a href="https://www.i18next.com/">i18next</a> library (along with
        <a href="https://react.i18next.com/">react-i18next</a>) to manage
        internationalization in a React application. To implement it, it is
        usually necessary to do this:
      </p>
      <ul>
        <li>Define an <code>i18next</code> instance</li>
      </ul>

      <pre
        data-path="src/i18n/index.js"
      ><code data-language="JavaScript">import i18n from "i18next";
import { initReactI18next } from "react-i18next";
import LanguageDetector from "i18next-browser-languagedetector";

import {
  en,
  ru,
  // ... other locales
} from "./locales";

const resources = {
  en,
  ru,
  // ... other locales
};

i18n
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    detection: {
      lookupQuerystring: "lng",
      order: ["querystring"],
    },

    fallbackLng: "en",
    interpolation: {
      // Not needed for React
      escapeValue: false,
    },
    resources,
  });

export default i18n;</code></pre>
      <ul>
        <li>Define the resources</li>
      </ul>

      <pre
        data-path="src/i18n/locales/index.js"
      ><code data-language="JavaScript">export { en } from "./en";
export { ru } from "./ru";
// ... other locales</code></pre>

      <pre
        data-path="src/i18n/locales/en/index.js"
      ><code data-language="JavaScript">import errors from "./errors.json";
// ... other namespaces

const en = {
  errors,
  // ... other namespaces
};

export { en };</code></pre>

      <pre
        data-path="src/i18n/locales/en/errors.json"
      ><code data-language="JSON">{
  "validation": {
    "field": {
      "is": {
        "empty": "This field is required",
        "incorrect": {
          "password": "Password is incorrect"
        },
        "invalid": {
          "common": "Please enter a valid value",
          "email": "Please enter a valid email address"
        }
      },
      "length": {
        "lessThan": "This field should contain at least {{minLength}} characters",
        "moreThan": "This field should contain no more than {{maxLength}} characters"
      }
    },
    "fields": {
      "are": {
        "not": {
          "equal": {
            "password": "Passwords don't match"
          }
        }
      }
    }
  }
}</code></pre>

      <pre
        data-path="src/i18n/locales/ru/index.js"
      ><code data-language="JavaScript">import errors from "./errors.json";
// ... other namespaces

const ru = {
  errors,
  // ... other namespaces
};

export { ru };</code></pre>

      <pre
        data-path="src/i18n/locales/ru/errors.json"
      ><code data-language="JSON">{
  "validation": {
    "field": {
      "is": {
        "empty": "Это поле является обязательным для заполнения",
        "incorrect": {
          "password": "Неверный пароль"
        },
        "invalid": {
          "common": "Пожалуйста, введите корректное значение",
          "email": "Пожалуйста, введите корректный адрес электронной почты"
        }
      },
      "length": {
        "lessThan": "Это поле должно состоять минимум из {{minLength}} символов",
        "moreThan": "Это поле должно состоять максимум из {{maxLength}} символов"
      }
    },
    "fields": {
      "are": {
        "not": {
          "equal": {
            "password": "Пароли не совпадают"
          }
        }
      }
    }
  }
}</code></pre>
      <ul>
        <li>Import the <code>i18n</code> instance</li>
      </ul>

      <pre
        data-path="src/main.jsx"
      ><code data-language="JavaScript">import * as React from "react";
import ReactDOM from "react-dom";

import "./i18n";
import { App } from "./app";

ReactDOM.render(
  &#x3C;React.StrictMode>
    &#x3C;App />
  &#x3C;/React.StrictMode>,
  document.getElementById("root"),
);</code></pre>
      <ul>
        <li>
          Pass the translation function to a component via special HOC/React
          Hook
        </li>
      </ul>

      <pre
        data-path="src/components/app.jsx"
      ><code data-language="JavaScript">import * as React from "react";
// The HOC
import { withTranslation } from "react-i18next";

const App = ({ t }) => {
  /*
    "This field should contain at least 10 characters" for English.
    "Это поле должно состоять минимум из 10 символов" for Russian.
  */
  const translatedText = t("errors:validation.field.length.lessThan", {
    minLength: 10,
  });

  return &#x3C;h1>{translatedText}&#x3C;/h1>;
};

const AppWithTranslation = withTranslation()(App);

export { AppWithTranslation as App };</code></pre>
      <p>Or</p>
      <pre
        data-path="src/components/app.jsx"
      ><code data-language="JavaScript">import * as React from "react";
// The React Hook
import { useTranslation } from "react-i18next";

const App = () => {
  const { t } = useTranslation();

  /*
    "This field should contain at least 10 characters" for English.
    "Это поле должно состоять минимум из 10 символов" for Russian.
  */
  const translatedText = t("errors:validation.field.length.lessThan", {
    minLength: 10,
  });

  return &#x3C;h1>{translatedText}&#x3C;/h1>;
};

export { App };</code></pre>
      <p>
        Either way, the component gets the <code>t</code> function. The function
        accepts a path to a localization string (see JSON files above), and an
        object with variables, which are put in the slots (defined in double
        curly braces) in the string.
      </p>
      <p>
        The full source code can be found here:
        <a
          href="https://github.com/vasilii-kovalev/react-internationalization-i18next"
          >link</a
        >.
      </p>
      <h2 id="the-problems"><a href="#the-problems">The problems</a></h2>
      <p>
        The whole approach looks reasonable, but there are some problems with
        it:
      </p>
      <ul>
        <li>
          Path to a localization string is a plain string, so it is easy to make
          typos. It is also easy to forget to define a namespace or make typos
          in it as well. It is necessary to thoroughly check each part of the
          path to make sure it leads to a correct localization string.
        </li>
        <li>
          The packages are heavy: the described approach in total takes ~55.1
          KiB, ~51 KiB of which is the packages' code. Check out "Measuring
          application sizes" section below for more information.
        </li>
        <li>
          It is hard to keep the files' structure synchronized between locales.
          A sub-tree can be missed in a resource, and nothing will tell about
          that until
          <a
            href="https://www.i18next.com/overview/configuration-options#missing-keys"
            >missing keys</a
          >
          feature will handle it (if enabled).
        </li>
      </ul>
      <p>
        We wrote that application using JavaScript back then. After several
        years I learned TypeScript and realized, how to solve all these
        problems.
      </p>
      <h2 id="the-solution"><a href="#the-solution">The solution</a></h2>
      <p>
        I like the API of the <code>t</code> function (path to a localization
        string and a bunch of variables to "hydrate" it), so I decided to copy
        it in a standalone package, that is known as
        <a href="https://github.com/vasilii-kovalev/hydrate-text"
          >"hydrate-text"</a
        >. Now let's implement our own i18n solution with it.
      </p>
      <ul>
        <li>Define supported languages and a default one</li>
      </ul>

      <pre
        data-path="src/i18n/constants.ts"
      ><code data-language="TypeScript">const SUPPORTED_LANGUAGES_MAP = {
  en: "en",
  ru: "ru",
  // ... other languages
} as const;

const DEFAULT_SELECTED_LANGUAGE = SUPPORTED_LANGUAGES_MAP.en;

export { DEFAULT_SELECTED_LANGUAGE, SUPPORTED_LANGUAGES_MAP };</code></pre>
      <ul>
        <li>
          Define a "dictionary" (a structure, that will be used to type checking
          our localization resources)
        </li>
      </ul>

      <pre
        data-path="src/i18n/dictionary/index.ts"
      ><code data-language="TypeScript">import { errors } from "./errors";
// ... other namespaces

const dictionary = {
  errors,
  // ... other namespaces
} as const;

export { dictionary };</code></pre>

      <pre
        data-path="src/i18n/dictionary/errors.ts"
      ><code data-language="TypeScript">const errors = {
  validation: {
    field: {
      is: {
        empty: "errors.validation.field.is.empty",
        incorrect: {
          password: "errors.validation.field.is.incorrect.password",
        },
        invalid: {
          common: "errors.validation.field.is.invalid.common",
          email: "errors.validation.field.is.invalid.email",
        },
      },
      length: {
        lessThan: "errors.validation.field.length.lessThan",
        moreThan: "errors.validation.field.length.moreThan",
      },
    },
    fields: {
      are: {
        not: {
          equal: {
            password: "errors.validation.fields.are.not.equal.password",
          },
        },
      },
    },
  },
} as const;

export { errors };</code></pre>
      <p>
        <code>as const</code> expressions require all the resources to strictly
        follow the structure.
      </p>
      <p>
        Note: it can be hard to fill in these strings manually, so I just assign
        empty strings to them and pass the whole structure to this function
        below.
      </p>
      <pre><code data-language="JavaScript">const fillTreePaths = (treeWithEmptyPaths, namespace = "") => {
  const traverse = (currentTree, parentPath) =>
    Object.entries(currentTree).reduce((updatedCurrentTree, [key, value]) => {
      const currentPath = `${parentPath}.${key}`;

      if (typeof value === "string") {
        return {
          ...updatedCurrentTree,
          [key]: currentPath,
        };
      }

      return {
        ...updatedCurrentTree,
        [key]: traverse(value, currentPath),
      };
    }, {});

  const newTree = traverse(treeWithEmptyPaths, namespace);

  const stringifiedTree = JSON.stringify(newTree, null, 2);
  const refinedTree = stringifiedTree
    // Removes double quote before keys.
    .replace(/(\s{2,})"/g, "$1")
    // Removes double quote right after keys and before colons.
    .replace(/"(: )/g, "$1");

  return refinedTree;
};

/*
Returns
{
  validation: {
    field: {
      is: {
        empty: "errors.validation.field.is.empty",
        incorrect: {
          password: "errors.validation.field.is.incorrect.password",
        },
        invalid: {
          common: "errors.validation.field.is.invalid.common",
          email: "errors.validation.field.is.invalid.email",
        },
      },
      length: {
        lessThan: "errors.validation.field.length.lessThan",
        moreThan: "errors.validation.field.length.moreThan",
      },
    },
    fields: {
      are: {
        not: {
          equal: {
            password: "errors.validation.fields.are.not.equal.password",
          },
        },
      },
    },
  },
}
*/
fillTreePaths(
  {
    validation: {
      field: {
        is: {
          empty: "",
          incorrect: {
            password: "",
          },
          invalid: {
            common: "",
            email: "",
          },
        },
        length: {
          lessThan: "",
          moreThan: "",
        },
      },
      fields: {
        are: {
          not: {
            equal: {
              password: "",
            },
          },
        },
      },
    },
  },
  "errors",
);</code></pre>
      <ul>
        <li>Define types for the resources</li>
      </ul>

      <pre
        data-path="src/i18n/types.ts"
      ><code data-language="TypeScript">import { SUPPORTED_LANGUAGES_MAP } from "./constants";
import { dictionary } from "./dictionary";

type Keys&#x3C;Type> = keyof Type;

type Values&#x3C;Type> = Type[Keys&#x3C;Type>];

/*
  Turns particular string values into abstract 'string' type.
  It allows to type translations with I18nPaths subtypes, because otherwise
  TypeScript will be complaining that values of translations are not the same
  as paths ones.
*/
type GetDictionary&#x3C;Type> = Type extends string
  ? string
  : { [Path in Keys&#x3C;Type>]: GetDictionary&#x3C;Type[Path]> };

type Dictionary = GetDictionary&#x3C;typeof dictionary>;

type SupportedLanguage = Values&#x3C;typeof SUPPORTED_LANGUAGES_MAP>;

type Dictionaries = {
  [Language in SupportedLanguage]: Dictionary;
};

export type { Dictionaries, Dictionary, SupportedLanguage };</code></pre>
      <ul>
        <li>
          Define the resources (I called them <code>dictionaries</code> for
          consistency) for the supported languages
        </li>
      </ul>

      <pre
        data-path="src/i18n/dictionaries/index.ts"
      ><code data-language="TypeScript">import { Dictionaries } from "../types";

import { englishDictionary as en } from "./en";
import { russianDictionary as ru } from "./ru";
// ... other dictionaries

const dictionaries: Dictionaries = {
  en,
  ru,
  // ... other dictionaries
};

export { dictionaries };</code></pre>

      <pre
        data-path="src/i18n/dictionaries/en/index.ts"
      ><code data-language="TypeScript">import { Dictionary } from "i18n/types";

import { errors } from "./errors";
// ... other namespaces

const englishDictionary: Dictionary = {
  errors,
  // ... other namespaces
};

export { englishDictionary };</code></pre>

      <pre
        data-path="src/i18n/dictionaries/en/errors.ts"
      ><code data-language="TypeScript">import { Dictionary } from "i18n/types";

const errors: Dictionary["errors"] = {
  validation: {
    field: {
      is: {
        empty: "This field is required",
        incorrect: {
          password: "Password is incorrect",
        },
        invalid: {
          common: "Please enter a valid value",
          email: "Please enter a valid email address",
        },
      },
      length: {
        lessThan: "This field should contain at least {minLength} characters",
        moreThan: `This field should contain no more than {maxLength}
        characters`,
      },
    },
    fields: {
      are: {
        not: {
          equal: {
            password: "Passwords don't match",
          },
        },
      },
    },
  },
};

export { errors };</code></pre>

      <pre
        data-path="src/i18n/dictionaries/ru/index.ts"
      ><code data-language="TypeScript">import { Dictionary } from "i18n/types";

import { errors } from "./errors";
// ... other namespaces

const russianDictionary: Dictionary = {
  errors,
  // ... other namespaces
};

export { russianDictionary };</code></pre>

      <pre
        data-path="src/i18n/dictionaries/ru/errors.ts"
      ><code data-language="TypeScript">import { Dictionary } from "i18n/types";

const errors: Dictionary["errors"] = {
  validation: {
    field: {
      is: {
        empty: "Это поле является обязательным для заполнения",
        incorrect: {
          password: "Неверный пароль",
        },
        invalid: {
          common: "Пожалуйста, введите корректное значение",
          email: "Пожалуйста, введите корректный адрес электронной почты",
        },
      },
      length: {
        lessThan: "Это поле должно состоять минимум из {minLength} символов",
        moreThan: "Это поле должно состоять максимум из {maxLength} символов",
      },
    },
    fields: {
      are: {
        not: {
          equal: {
            password: "Пароли не совпадают",
          },
        },
      },
    },
  },
};

export { errors };</code></pre>
      <ul>
        <li>Create i18n context, context provider and React Hook</li>
      </ul>

      <pre
        data-path="src/i18n/context.tsx"
      ><code data-language="TypeScript">import { HydrateText } from "hydrate-text";
import * as React from "react";

import { DEFAULT_SELECTED_LANGUAGE } from "./constants";
import { SupportedLanguage } from "./types";
import { isSupportedLanguage, textResolver } from "./utils";
import { dictionaries } from "./dictionaries";

interface I18nContextInterface {
  selectedLanguage: SupportedLanguage;
  setLanguage: (newSelectedLanguage: SupportedLanguage) => void;
  translate: HydrateText;
}

const I18nContext = React.createContext&#x3C;I18nContextInterface>({
  selectedLanguage: DEFAULT_SELECTED_LANGUAGE,
  setLanguage: () => {
    // no-op
  },
  translate: () => "",
});

const I18nProvider: React.FC = ({ children }) => {
  const [selectedLanguage, setLanguage] = React.useState&#x3C;SupportedLanguage>(
    DEFAULT_SELECTED_LANGUAGE,
  );

  React.useEffect(() => {
    const searchParams = new URLSearchParams(window.location.search);

    const language = searchParams.get("lng");

    if (isSupportedLanguage(language)) {
      setLanguage(language);
    }
  }, []);

  const translate = React.useMemo(
    () => textResolver(dictionaries[selectedLanguage]),
    [selectedLanguage],
  );

  return (
    &#x3C;I18nContext.Provider
      value={{
        selectedLanguage,
        setLanguage,
        translate,
      }}
    >
      {children}
    &#x3C;/I18nContext.Provider>
  );
};

const useI18n = (): I18nContextInterface => {
  return React.useContext(I18nContext);
};

export { I18nContext, I18nProvider, useI18n };</code></pre>

      <pre
        data-path="src/i18n/utils.ts"
      ><code data-language="TypeScript">import { HydrateText, hydrateText } from "hydrate-text";
import get from "lodash/get";

import { SUPPORTED_LANGUAGES_MAP } from "./constants";
import { Dictionary, SupportedLanguage } from "./types";

const textResolver =
  (dictionary: Dictionary): HydrateText =>
  (pathOrText, variables, interpolationOptions) => {
    return hydrateText(
      get(dictionary, pathOrText, pathOrText),
      variables,
      interpolationOptions,
    );
  };

const isSupportedLanguage = (
  language: string | null,
): language is SupportedLanguage => {
  return Object.values(SUPPORTED_LANGUAGES_MAP).includes(
    language as SupportedLanguage,
  );
};

export { textResolver, isSupportedLanguage };</code></pre>
      <ul>
        <li>Wrap the application in the context provider</li>
      </ul>

      <pre
        data-path="src/main.tsx"
      ><code data-language="TypeScript">import * as React from "react";
import ReactDOM from "react-dom";

import { I18nProvider } from "i18n";

import { App } from "./app";

ReactDOM.render(
  &#x3C;React.StrictMode>
    &#x3C;I18nProvider>
      &#x3C;App />
    &#x3C;/I18nProvider>
  &#x3C;/React.StrictMode>,
  document.getElementById("root"),
);</code></pre>
      <ul>
        <li>Use the React Hook to get the translation function</li>
      </ul>

      <pre
        data-path="src/app.tsx"
      ><code data-language="TypeScript">import * as React from "react";

import { dictionary, useI18n } from "i18n";

const { field } = dictionary.errors.validation;

const App: React.VFC = () => {
  const { translate } = useI18n();

  /*
    "This field should contain at least 10 characters" for English.
    "Это поле должно состоять минимум из 10 символов" for Russian.
  */
  const translatedText = translate(field.length.lessThan, {
    minLength: 10,
  });

  return &#x3C;h1>{translatedText}&#x3C;/h1>;
};

export { App };</code></pre>
      <p>
        The full source code can be found here:
        <a
          href="https://github.com/vasilii-kovalev/react-internationalization-hydrate-text"
          >link</a
        >.
      </p>
      <p>Now all the problems are solved:</p>
      <ul>
        <li>
          The path to a localization string is not a plain string now, but a
          structure, that won't let you make a typo.
        </li>
        <li>
          The described approach adds ~8.3 KiB to the bundle (the heaviest part
          is
          <a href="https://lodash.com/docs/4.17.15#get"
            ><code>get</code> function from Lodash</a
          >, that takes ~6.8 KiB). It is a way smaller than the previous one,
          and it is fully customizable on any level. Check out "Measuring
          application sizes" section below for more information.
        </li>
        <li>
          <code>Dictionary</code> type guarantees, that all resources
          (dictionaries) have the same structure.
        </li>
      </ul>
      <h2 id="keeping-text-organized">
        <a href="#keeping-text-organized">Keeping text organized</a>
      </h2>
      <p>
        Even if localization is not necessary, I believe it is still a good idea
        to keep text organized. In this case, the following approach can be
        used:
      </p>
      <ul>
        <li>Define a text constant</li>
      </ul>

      <pre
        data-path="src/constants/text/errors.ts"
      ><code data-language="TypeScript">const ERRORS_TEXT = {
  validation: {
    field: {
      is: {
        empty: "This field is required",
        incorrect: {
          password: "Password is incorrect",
        },
        invalid: {
          common: "Please enter a valid value",
          email: "Please enter a valid email address",
        },
      },
      length: {
        lessThan: "This field should contain at least {minLength} characters",
        moreThan: `This field should contain no more than {maxLength}
        characters`,
      },
    },
    fields: {
      are: {
        not: {
          equal: {
            password: "Passwords don't match",
          },
        },
      },
    },
  },
};</code></pre>
      <ul>
        <li>
          Use <code>hydrate-text</code> to provide the text with variables
        </li>
      </ul>

      <pre
        data-path="src/app.tsx"
      ><code data-language="TypeScript">import { hydrateText } from "hydrate-text";
import * as React from "react";

import { ERRORS_TEXT } from "constants/text/errors";

const { field } = ERRORS_TEXT.validation;

const App: React.VFC = () => {
  /*
    "This field should contain at least 10 characters".
  */
  const text = hydrateText(field.length.lessThan, {
    minLength: 10,
  });

  return &#x3C;h1>{text}&#x3C;/h1>;
};

export { App };</code></pre>
      <h2 id="replacing-route-variables">
        <a href="#replacing-route-variables">Replacing route variables</a>
      </h2>
      <p>
        In some cases, it is necessary to provide
        <a href="https://reactrouter.com/">React Router</a> routes with
        variables, like this:
      </p>
      <pre><code data-language="TypeScript">// Given
"/posts/:id";

// Needed (for example, `id` is 10)
"/posts/10";</code></pre>
      <p>
        To achieve this, an ability to replace default variable markers was
        added. In the source code it is called "interpolation options" (this
        name was taken from <code>i18next</code>
        <a
          href="https://www.i18next.com/translation-function/interpolation#additional-options"
          >"Interpolation" page</a
        >):
      </p>
      <pre><code data-language="TypeScript">// "/posts/10"
hydrateText("/posts/:id", { id: 10 }, { prefix: ":" });</code></pre>
      <p>
        If it is necessary to do this in several places, it is better to use
        another function from <code>hydrate-text</code> -
        <code>configureHydrateText</code>, which will return
        <code>hydrateText</code> function bound to the chosen variable markers:
      </p>
      <pre><code data-language="TypeScript">const hydrateRoute = configureHydrateText({ prefix: ":" });

// "/posts/10"
hydrateRoute("/posts/:id", { id: 10 });</code></pre>
      <p>
        The markers still can be changed via the third argument, but I can
        hardly imagine, when it can be useful 🙂
      </p>
      <p>
        Later on I found a built-in function
        <a href="https://reactrouter.com/web/api/generatePath">generatePath</a>,
        but the examples above are still valid as an illustration of the
        variable markers changing flexibility.
      </p>
      <h2 id="measuring-application-sizes">
        <a href="#measuring-application-sizes">Measuring application sizes</a>
      </h2>
      <h3 id="i18next"><a href="#i18next">i18next</a></h3>
      <p>
        In each case, check console results and sum up
        <code>dist/assets/index.&#x3C;hash>.js</code> and
        <code>dist/assets/vendor.&#x3C;hash>.js</code> sizes.
      </p>
      <ol>
        <li>
          Build the application as is: <strong>1.34 KiB + 181.54 KiB</strong>.
        </li>
        <li>
          Replace <code>&#x3C;App /></code> by <code>null</code>, comment out
          <code>i18n</code> and <code>App</code> imports and build the
          application: <strong>0.14 KiB + 127.59 KiB</strong>.
        </li>
      </ol>
      <p>
        The sizes were double-checked with
        <a
          href="https://marketplace.visualstudio.com/items?itemName=mkxml.vscode-filesize"
          >filesize</a
        >
        VS Code extension.
      </p>
      <p>
        We miss <code>withTranslation</code>/<code>useTranslation</code> import
        costs, but I don't think it drastically changes the picture.
      </p>
      <h3 id="hydrate-text"><a href="#hydrate-text">hydrate-text</a></h3>
      <p>
        In each case, check console results and sum up
        <code>dist/assets/index.&#x3C;hash>.js</code> and
        <code>dist/assets/vendor.&#x3C;hash>.js</code> sizes.
      </p>
      <ol>
        <li>
          Build the application as is: <strong>2.16 KiB + 133.91 KiB</strong>.
        </li>
        <li>
          Replace <code>get(dictionary, pathOrText, pathOrText)</code> by
          <code>pathOrText</code>, comment out <code>get</code> import and build
          the application: <strong>1.25 KiB + 128.01 KiB</strong>.
        </li>
        <li>
          Replace
          <code>&#x3C;I18nProvider>&#x3C;App />&#x3C;/I18nProvider></code> by
          <code>null</code>, comment out <code>I18nProvider</code> and
          <code>App</code> imports and build the application:
          <strong>0.14 KiB + 127.59 KiB</strong>.
        </li>
      </ol>
      <p>
        The sizes were double-checked with
        <a
          href="https://marketplace.visualstudio.com/items?itemName=mkxml.vscode-filesize"
          >filesize</a
        >
        VS Code extension.
      </p>
    </main>

    <footer>
      Spotted a mistake? Post is too difficult to understand or incorrectly
      written? Please, create an issue
      <a href="https://github.com/vasilii-kovalev/blog/issues">here</a> and
      let's discuss it!
    </footer>
  </body>
</html>
